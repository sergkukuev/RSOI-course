Лабораторная работа #5
Авторизация

Формулировка:
	Основываясь на наработках из предыдущих лабораторных, реализовать OAuth2 авторизацию для API и пользовательского интерфейса, а так использование токена при взаимодействии между сервисами.

Требования
	1. Все операции между сервером и клиентом разделить на публичные и закры-тые. В REST API для выполнения закрытых операций использовать токен, полу-ченный с помощью OAuth 2 (code flow).
	2. Для пользовательского интерфейса реализовать login/password авторизацию, в результате на успешную авторизацию выдавать токен, идентифицирующий ав-торизованного пользователя. Все закрытые операции должны выполняться с помощью этого токена. Если для UI используется SPA и вся логика работы с сервером реализуется с помощью JavaScript, то токен передавать в заголовке Authorization: Bearer <token>. Если используется server rendering и для отправки формы выполняется синхронный submit, то токен можно хранить в cookies и пе-редавать через заголовок Cookie: <token-name>=<token>.
	3. Регистрацию нового пользователя делать не обязательно, достаточно создать несколько тестовых пользователей.
	4. Пароль в базе хранить в хэшированном виде.
	5. Выделить отдельный сервис, отвечающий за авторизацию. Все запросы от UI и API на проверку токенов делегируютя ему через Aggregation Service.
	6. Выданные токены хранить в некотором хранилище (можно в БД, redis, hazelcast и т.п.). На сервере не использовать встроенную сессию.
	7. Для взаимодействия между сервисами использовать токен, каждый сервис имеет <appnId>/<appSecret>, по этим данным выдается токен с некоторым вре-менем жизни. По окончанию времени жизни, токен требуется перезапросить. Авторизационные данные для доступа к каждому сервису знают сами сервисы, эти запросы не делегируются на Session Service.
	8. Все токены должны иметь время жизни.
	9. Для токена, полученного с помощью OAuth2, реализовать refresh токен.
	10. Токен, используемый в пользовательском интерфейсе, должен инвалидиро-ваться после 30 минут бездействия.
	11. Подготовить пример получения/обновления OAuth 2 токена, выполнения запро-сов к REST API.
	12. (опционально) Каждому сервису присвоить доменное имя (через /etc/hosts), между сервисами использовать HTTPS. Использовать nginx в качестве reverse-proxy, настройки HTTPS выполнять на нем.

Пояснение:
	AS – Aggregation Service
	OS – Order Sevice
	SS – Session Service

	На диаграмме представлен общий вид системы. Предположим, что выполено опциональное задание и настроен nginx, с его помощью настроено HTTPS соединение между сервисами и клиентом с Front End'ом. Клиент авторизуется через с помощью login/password, AS делегирует запрос на SS, в ответ ему отдается token, все операции он выполняет с помощью этого токена. Для REST API требуется запросить токен через OAuth 2 code flow, в ответ получить токен и все операции выполнять так же с исполь-зованием этого токена.

	Предположим, AS делает запрос к OS, для этого ему требуется получить токен (без токена на запрос отдается 401 ошибка). Сервис AS имеет <appKey>/<appSecret>, эти данные знает сервис OS. Сервис AS делает запрос к OS, передавая эти данные в хедере Authorization: Basic base64(<appKey>:<appSecret>). В ответ на успешную авто-ризацию сервис OS отдает токен. Токен имеет время жизни и по окончанию времени жизни сервис AS должен перезапросить новый токен.

	см. lab5.jpg